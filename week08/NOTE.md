### 第 8 周第 1 节内容：TTT | 实现一个 TTT 游戏
一. 三子棋规则：
棋盘：3 * 3
双方分别持有圆圈和叉两种棋子
双方交替落子
率先连成三子直线的一方获胜

二. 思路
1. 先画出棋盘
棋盘用二维数组表示。
棋盘的状态有 3 种：空，圈和叉。分别用 0， 1，2 来表示。
对二维数组进行双层遍历，画出棋盘。

2. 点击时画上圈和叉
对每个块进行事件监听，每点一次更新一下二维数组，再对新二维数组进行重绘。
小细节是，点的时候是圈和叉交替的。

3. 分出胜负
胜利的情况一共有 8 种，三横三纵两斜。
先检查三个横行，刚刚下的棋的颜色是用 color 变量表示的，在某一个横行中，有不是 color 的，肯定没有成功。 再检查三列，同三横行。 再检查两个斜向，同上。

4. 加入 AI，下子前提示"你将要赢了"
循环遍历空节点，只要有一个能赢，就可以提示"将要赢"。

### 第 8 周第 2 节内容：TTT | 给游戏添加一个完美的 AI
一. 思路
1. 策略
第一层策略：我要赢
第二层策略：别输
第三层策略：走完之后，对方不管怎么走，我们都不会输。

2.找出最佳选择，包含了位置和结果，即point 和 result: -1 | + 1 | 0
其中会模拟走棋，比如我方先走，那么找出对方最差的结果，即是我方最好的结果，把这个结果为我所有。
重复上述过程，有更好结果时，抛弃上次结果，把本次记下，直到二维数组遍历完。

3. 保存棋盘的其它思路：一维数组
用乘法区分行与列。
把 [i][j] 换成 [i * 3 + j]，类似也这样替换。
其它细节：clone 函数替换；bestChoice 中双循环的退出。

4. 人机对战，机器自动走最佳棋子
其实和己方一样，只不过机器多了一步"找最佳选择"，而这一步，己方是自己想，机器则是用算法想。

### 第 8 周第 3 节内容：异步编程 | async 异步编程
一. JS 异步机制：callback/Promise/async
callback： 会有嵌套地狱的问题。
Promise： 仍然是回调，只不过用链式代替了嵌套。Promise 中可以使用 setTimeout，等待一定时间执行；也可以添加事件，此时需要事件发生才 resolve()。
new Promise((resolve, reject) => { element.addEventListener(eventName, resolve); })
async/await：用同步代码来执行异步。
二. generator
执行后返回一个遍历器对象，有 next()，调用后，返回一个对象 { value, done }
generator 遇到 yield 会停下来，co 模块可以让它自动执行。
generator + co = async/await
async generator 与 for await of：generator 中也可以返回一个异步遍历器，可以用 for await of 去遍历。
我的理解是 generator 中如果 yield 后面是异步，那么返回的就是异步遍历器，要用 for await of，否则用 for of 就行。